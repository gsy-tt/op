name: Build OpenWrt for JD BE6500 (IPQ5332)

on:
  workflow_dispatch:  # 手动触发
    inputs:
      with_wsdd2:
        description: '编译包含 WSDD2 (SMB3 支持)'
        required: false
        default: 'true'
        type: boolean
      with_samba4:
        description: '编译包含 Samba4'
        required: false
        default: 'true'
        type: boolean
      with_docker:
        description: '编译包含 Docker 支持'
        required: false
        default: 'true'
        type: boolean
  release:
    types: published  # 发布Release时触发

env:
  LIENOL_REPO: https://github.com/Lienol/openwrt          # Lienol主仓库
  LIENOL_BRANCH: 23.05                                  # 使用23.05分支
  ARCH: ipq807x                                          # 使用ipq807x目标（兼容IPQ5332）
  SUBARCH: generic                                       # 通用子架构
  CPU_ARCH: aarch64_cortex-a53                           # CPU架构
  FEEDS_CONF: feeds.conf.default                         # Feeds配置文件
  CONFIG_FILE: .config                                   # 编译配置文件
  DIY_P1_SH: diy-part1.sh                                # 自定义脚本1
  DIY_P2_SH: diy-part2.sh                                # 自定义脚本2
  UPLOAD_BIN_DIR: false                                  # 不上传bin目录
  UPLOAD_FIRMWARE: true                                  # 上传固件
  UPLOAD_RELEASE: true                                   # 发布到Release
  UPLOAD_CDN: false                                      # 上传到CDN
  TZ: Asia/Shanghai                                      # 时区
  GITHUB_TOKEN: ${{ secrets.MY_TOKEN }}                  # GitHub Token
  CACHE_DIR: ${{ github.workspace }}/.cache/openwrt       # 缓存目录

jobs:
  build:
    runs-on: ubuntu-22.04                                 # 直接使用Ubuntu环境

    steps:
    - name: 检查环境
      run: |
        df -hT
        free -h
        cat /proc/cpuinfo
        cat /etc/os-release

    - name: 安装OpenWrt编译依赖
      run: |
        sudo apt-get update
        # 安装OpenWrt官方推荐的编译依赖
        sudo apt-get install -y build-essential ccache ecj fastjar file g++ gawk \
          gettext git java-propose-classpath libelf-dev libncurses5-dev \
          libncursesw5-dev libssl-dev python3 python3-distutils python3-setuptools \
          python3-dev rsync subversion swig time unzip wget xmlto zlib1g-dev \
          quilt autopoint libtool-bin gperf flex bison gettext-base asciidoc dos2unix \
          python3-pyelftools python3-pip
        pip install pyelftools

    - name: 配置Git凭证
      run: |
        git config --global credential.helper store
        echo "https://${GITHUB_TOKEN}:@github.com" > ~/.git-credentials
        echo "Git凭证已配置"

    - name: 克隆Lienol仓库（带重试机制）
      run: |
        rm -rf openwrt
        for i in {1..5}; do
          echo "=== 第 $i 次克隆尝试 ==="
          git clone --depth=1 $LIENOL_REPO -b $LIENOL_BRANCH openwrt
          if [ $? -eq 0 ]; then
            echo "✅ 仓库克隆成功"
            break
          fi
          echo "❌ 克隆失败，15秒后重试..."
          sleep 15
        done
        if [ ! -d "openwrt" ]; then
          echo "💥 五次克隆失败，退出"
          exit 1
        fi
        cd openwrt
        echo "OPENWRT_PATH=$(pwd)" >> $GITHUB_ENV
        git log -1

    - name: 缓存依赖包（加速编译）
      uses: actions/cache@v3
      with:
        path: ${{ env.CACHE_DIR }}
        key: ${{ runner.os }}-openwrt-dl-${{ hashFiles('openwrt/dl/**', 'feeds.conf.default', '.config') }}
        restore-keys: |
          ${{ runner.os }}-openwrt-dl-

    - name: 智能Feeds配置（去重+依赖修复）
      run: |
        cd $OPENWRT_PATH
        # 备份原始Feeds配置
        cp $FEEDS_CONF ${FEEDS_CONF}.bak
        
        # 1. 清理重复源并确保唯一性
        UNIQUE_FEEDS=$(cat $FEEDS_CONF | grep -v '^#' | sort -u | awk '!a[$2]++')
        > $FEEDS_CONF
        echo "$UNIQUE_FEEDS" >> $FEEDS_CONF
        
        # 2. 添加必要源（使用唯一名称）
        if ! grep -q "lienol" $FEEDS_CONF; then
          echo "src-git lienol https://github.com/Lienol/openwrt-package" >> $FEEDS_CONF
        fi
        if ! grep -q "kenzo" $FEEDS_CONF; then
          echo "src-git kenzo https://github.com/kenzok8/openwrt-packages" >> $FEEDS_CONF
        fi
        if ! grep -q "small" $FEEDS_CONF; then
          echo "src-git small https://github.com/kenzok8/small" >> $FEEDS_CONF
        fi
        
        # 3. 使用唯一名称添加官方源
        if ! grep -q "openwrt_packages" $FEEDS_CONF; then
          echo "src-git openwrt_packages https://git.openwrt.org/feed/packages.git^openwrt-23.05" >> $FEEDS_CONF
        fi
        if ! grep -q "openwrt_luci" $FEEDS_CONF; then
          echo "src-git openwrt_luci https://git.openwrt.org/project/luci.git^openwrt-23.05" >> $FEEDS_CONF
        fi
        if ! grep -q "openwrt_routing" $FEEDS_CONF; then
          echo "src-git openwrt_routing https://git.openwrt.org/feed/routing.git^openwrt-23.05" >> $FEEDS_CONF
        fi
        if ! grep -q "openwrt_telephony" $FEEDS_CONF; then
          echo "src-git openwrt_telephony https://git.openwrt.org/feed/telephony.git^openwrt-23.05" >> $FEEDS_CONF
        fi
        
        # 4. 添加IPQ5332特定驱动源
        if ! grep -q "ipq5332_drivers" $FEEDS_CONF; then
          echo "src-git ipq5332_drivers https://github.com/yourusername/openwrt-ipq5332-drivers" >> $FEEDS_CONF
        fi
        
        # 5. 显示最终Feeds配置
        echo "=== 最终Feeds配置 ==="
        cat $FEEDS_CONF

    - name: 依赖强化安装（解决历史报错）
      run: |
        cd $OPENWRT_PATH
        # 清理旧Feeds
        rm -rf feeds/*
        
        # 多轮Feeds更新（解决网络波动）
        for i in {1..3}; do
          echo "=== 第 $i 次Feeds更新 ==="
          ./scripts/feeds update -a 2>&1 | tee feeds_update_${i}.log
          if [ $? -eq 0 ]; then
            break
          fi
          echo "更新失败，10秒后重试..."
          sleep 10
        done
        
        # 安装Feeds（带依赖修复）
        ./scripts/feeds install -a 2>&1 | tee feeds_install.log
        
        # 确保IPQ5332驱动被安装
        if ! ./scripts/feeds list | grep -q "kmod-ath11k-ct"; then
          echo "⚠️ 未找到IPQ5332 Wi-Fi驱动，从OpenWrt官方仓库获取..."
          
          # 修正：直接克隆ath11k模块而非完整仓库
          mkdir -p package/kernel
          git clone -b openwrt-23.05 --depth=1 https://github.com/openwrt/openwrt.git openwrt_temp
          
          # 检查模块是否存在
          if [ -d "openwrt_temp/package/kernel/ath11k" ]; then
            cp -r openwrt_temp/package/kernel/ath11k package/kernel/
            echo "✅ ath11k驱动已复制到package/kernel目录"
          else
            echo "❌ 未在临时仓库中找到ath11k模块"
            echo "尝试从OpenWrt官方feed获取..."
            git clone -b openwrt-23.05 --depth=1 https://git.openwrt.org/openwrt/openwrt.git openwrt_feed
            if [ -d "openwrt_feed/package/kernel/ath11k" ]; then
              cp -r openwrt_feed/package/kernel/ath11k package/kernel/
              echo "✅ 从官方feed获取ath11k成功"
            else
              echo "❌ 无法获取ath11k驱动，尝试从其他源获取"
              # 备选方案：直接从ath11k-ct项目获取
              git clone -b master --depth=1 https://github.com/qca-open-wrt/ath11k-ct.git package/kernel/ath11k-ct
              if [ -d "package/kernel/ath11k-ct" ]; then
                echo "✅ 已获取ath11k-ct替代驱动"
              else
                echo "💥 所有方法均无法获取Wi-Fi驱动，构建终止"
                exit 1
              fi
            fi
          fi
          
          # 清理临时文件
          rm -rf openwrt_temp openwrt_feed
        else
          echo "✅ IPQ5332 Wi-Fi驱动已安装"
        fi

    - name: 基础配置生成（保留并强化目标平台）
      run: |
        cd $OPENWRT_PATH
        # 保留原有.config配置，但确保目标平台正确设置
        if [ -f "$CONFIG_FILE" ]; then
          echo "✅ 检测到已有配置文件，保留并更新目标平台配置"
          # 备份原配置
          cp $CONFIG_FILE ${CONFIG_FILE}.bak
          
          # 确保目标平台正确设置
          sed -i '/CONFIG_TARGET_IPQ807X/d' $CONFIG_FILE
          sed -i '/CONFIG_TARGET_IPQ807X_DEVICE_jd-be6500/d' $CONFIG_FILE
          echo "CONFIG_TARGET_IPQ807X=y" >> $CONFIG_FILE
          echo "CONFIG_TARGET_IPQ807X_DEVICE_jd-be6500=y" >> $CONFIG_FILE
          echo "CONFIG_TARGET_DEVICE_PACKAGES_jd-be6500=\"kmod-ath11k-ct kmod-qca-ppe kmod-qca-nss-drv kmod-qca-nss-gmac kmod-thermal-qcom\"" >> $CONFIG_FILE
          echo "CONFIG_TARGET_KERNEL_PARTSIZE=16" >> $CONFIG_FILE
          echo "CONFIG_TARGET_ROOTFS_PARTSIZE=128" >> $CONFIG_FILE
        else
          # 生成默认配置
          make defconfig
          
          # 设置目标平台
          echo "CONFIG_TARGET_IPQ807X=y" >> $CONFIG_FILE
          echo "CONFIG_TARGET_IPQ807X_DEVICE_jd-be6500=y" >> $CONFIG_FILE
          echo "CONFIG_TARGET_DEVICE_PACKAGES_jd-be6500=\"kmod-ath11k-ct kmod-qca-ppe kmod-qca-nss-drv kmod-qca-nss-gmac kmod-thermal-qcom\"" >> $CONFIG_FILE
          echo "CONFIG_TARGET_KERNEL_PARTSIZE=16" >> $CONFIG_FILE
          echo "CONFIG_TARGET_ROOTFS_PARTSIZE=128" >> $CONFIG_FILE
        fi
        
        # 显示当前配置（用于调试）
        echo "=== 当前.config 设备配置 ==="
        grep -E "CONFIG_TARGET_IPQ807X_DEVICE|CONFIG_TARGET_DEVICE_PACKAGES" .config

    - name: 设备树强制关联（关键修正）
      run: |
        cd $OPENWRT_PATH
        echo "=== 强制关联设备树到编译系统 ==="
        
        # 1. 确保设备树目录存在
        DTS_DIR="target/linux/$ARCH/dts"
        mkdir -p "$DTS_DIR"
        
        # 2. 复制或生成设备树文件
        DEVICE_TREE="$DTS_DIR/qcom,ipq5332-jd-be6500.dts"
        if [ ! -f "$DEVICE_TREE" ]; then
          echo "❌ 设备树不存在，从缓存复制或生成..."
          # 假设设备树已存在于仓库中，或从缓存复制
          if [ -f "qcom,ipq5332-jd-be6500.dts" ]; then
            cp "qcom,ipq5332-jd-be6500.dts" "$DEVICE_TREE"
          else
            # 生成设备树（此处使用简化版本，实际应使用完整设备树）
            echo '/dts-v1/;' > "$DEVICE_TREE"
            echo '#include "qcom,ipq5332.dtsi"' >> "$DEVICE_TREE"
            echo '#include "ipq807x.dtsi"' >> "$DEVICE_TREE"
            echo '' >> "$DEVICE_TREE"
            echo '/ {' >> "$DEVICE_TREE"
            echo '    model = "JD BE6500";' >> "$DEVICE_TREE"
            echo '    compatible = "qcom,ipq5332", "qcom,ipq5000", "qcom,ipq807x";' >> "$DEVICE_TREE"
            echo '    # 简化设备树内容，实际应使用完整配置' >> "$DEVICE_TREE"
            echo '};' >> "$DEVICE_TREE"
          fi
          echo "设备树已生成: $DEVICE_TREE"
        else
          echo "✅ 设备树已存在"
        fi
        
        # 3. 确保设备树被Makefile识别（关键修正）
        MAKEFILE="target/linux/$ARCH/Makefile"
        if ! grep -q "jd-be6500" "$MAKEFILE"; then
          echo "❌ 设备树未被Makefile识别，手动添加..."
          
          # 备份原Makefile
          cp "$MAKEFILE" "${MAKEFILE}.bak"
          
          # 添加设备定义
          sed -i "/define Device/generic/a\ \ \ \ \ DEVICE_PACKAGES += kmod-ath11k-ct kmod-qca-ppe kmod-qca-nss-drv kmod-qca-nss-gmac kmod-thermal-qcom" "$MAKEFILE"
          sed -i "/endef/a\ \ \ \ \ DEVICE_DTS := qcom,ipq5332-jd-be6500" "$MAKEFILE"
          
          if ! grep -q "qcom,ipq5332-jd-be6500" "$MAKEFILE"; then
            # 如果sed失败，使用追加方式
            echo "" >> "$MAKEFILE"
            echo "define Device/jd-be6500" >> "$MAKEFILE"
            echo "  \$(Device/generic)" >> "$MAKEFILE"
            echo "  DEVICE_TITLE := JD BE6500 (IPQ5332)" >> "$MAKEFILE"
            echo "  DEVICE_DTS := qcom,ipq5332-jd-be6500" >> "$MAKEFILE"
            echo "  DEVICE_PACKAGES := kmod-ath11k-ct kmod-qca-ppe kmod-qca-nss-drv kmod-qca-nss-gmac kmod-thermal-qcom" >> "$MAKEFILE"
            echo "endef" >> "$MAKEFILE"
            echo "\$(eval \$(call Device,jd-be6500))" >> "$MAKEFILE"
          fi
          
          if grep -q "jd-be6500" "$MAKEFILE"; then
            echo "✅ 设备树已添加到Makefile"
          else
            echo "❌ 设备树添加失败"
            exit 1
          fi
        else
          echo "✅ 设备树已被Makefile识别"
        fi

    - name: 应用diy-part1.sh脚本（自定义配置）
      run: |
        cd $OPENWRT_PATH
        if [ -f "$DIY_P1_SH" ]; then
          echo "执行自定义脚本: $DIY_P1_SH"
          chmod +x $DIY_P1_SH
          ./$DIY_P1_SH
        else
          echo "❌ 自定义脚本不存在: $DIY_P1_SH"
        fi

    - name: 应用diy-part2.sh脚本（自定义配置）
      run: |
        cd $OPENWRT_PATH
        if [ -f "$DIY_P2_SH" ]; then
          echo "执行自定义脚本: $DIY_P2_SH"
          chmod +x $DIY_P2_SH
          ./$DIY_P2_SH
        else
          echo "❌ 自定义脚本不存在: $DIY_P2_SH"
        fi

    - name: 下载依赖包（带缓存）
      run: |
        cd $OPENWRT_PATH
        echo "开始下载依赖包..."
        
        # 优先使用缓存
        if [ -d "${{ env.CACHE_DIR }}/dl" ]; then
          echo "使用缓存依赖包..."
          cp -rf "${{ env.CACHE_DIR }}/dl" .
        fi
        
        # 执行下载
        make download -j$(nproc) V=s
        DOWNLOAD_STATUS=$?
        
        # 保存缓存
        mkdir -p "${{ env.CACHE_DIR }}/dl"
        cp -rf dl/* "${{ env.CACHE_DIR }}/dl/"
        
        # 清理无效文件
        find dl -size -1024c -exec rm -f {} \;
        
        if [ $DOWNLOAD_STATUS -ne 0 ]; then
          echo "⚠️ 下载可能存在错误，继续构建..."
          find dl -type f -empty -exec echo "空文件: {}" \;
        else
          echo "✅ 依赖下载完成"
          echo "下载文件数: $(find dl -type f | wc -l)"
        fi

    - name: 编译固件（带详细错误日志）
      run: |
        cd $OPENWRT_PATH
        echo "开始编译固件... (IPQ5332专用)"
        echo "使用 $(nproc) 线程编译..."
        
        # 配置编译线程数（根据CPU核心数自动调整）
        JOBS=$(nproc)
        if [ $JOBS -gt 4 ]; then
          JOBS=4  # 限制最大线程数为4，避免内存不足
        fi
        
        # 生成配置（确保目标正确）
        make defconfig
        
        # 第一阶段：并行编译
        make -j$JOBS V=s 2>&1 | tee compile_phase1.log
        PHASE1_STATUS=$?
        
        if [ $PHASE1_STATUS -ne 0 ]; then
          echo "❌ 并行编译失败，尝试单线程编译..."
          # 第二阶段：单线程编译（获取详细错误）
          make -j1 V=s 2>&1 | tee compile_phase2.log
          PHASE2_STATUS=$?
          
          if [ $PHASE2_STATUS -ne 0 ]; then
            echo "💥 编译彻底失败，收集错误日志..."
            # 提取关键错误信息
            echo "=== 编译错误摘要 ==="
            grep -E "error:|fatal:|make\[.*:.*Error\]" compile_phase2.log || true
            
            # 保存完整日志
            mkdir -p error_logs
            cp compile_phase*.log error_logs/
            cp $(find . -name "*.err" -or -name "*.log") error_logs/ 2>/dev/null
            tar -czf error_logs.tar.gz error_logs
            exit 1
          else
            echo "✅ 单线程编译成功"
          fi
        else
          echo "✅ 并行编译成功"
        fi

    - name: 固件完整性检查（多级路径检测 - 关键修正）
      run: |
        cd $OPENWRT_PATH
        # 检测ipq807x目标固件路径（修正命名错误）
        FIRMWARE_PATH=$(find . -type d -name "ipq807x" 2>/dev/null | head -n1)
        if [ -n "$FIRMWARE_PATH" ]; then
          FIRMWARE_PATH="$FIRMWARE_PATH/generic"
        else
          FIRMWARE_PATH=$(find . -type d -name "qcom" 2>/dev/null | head -n1)
          if [ -n "$FIRMWARE_PATH" ]; then
            FIRMWARE_PATH="$FIRMWARE_PATH/generic"
          else
            FIRMWARE_PATH=$(find . -type d -name "generic" 2>/dev/null | grep -E "ipq807x|qcom" | head -n1)
            if [ -z "$FIRMWARE_PATH" ]; then
              echo "❌ 未找到ipq807x/qcom目标目录"
              echo "可用目标目录:"
              find . -type d -name "*" | grep targets
              exit 1
            fi
          fi
        fi
        
        if [ ! -d "$FIRMWARE_PATH" ]; then
          FIRMWARE_PATH=$(find . -type d -name "bin" 2>/dev/null | head -n1)
          if [ -n "$FIRMWARE_PATH" ]; then
            FIRMWARE_PATH="$FIRMWARE_PATH/$ARCH/$SUBARCH"
          fi
        fi
        
        if [ ! -d "$FIRMWARE_PATH" ]; then
          echo "❌ 未找到通用固件目录"
          echo "可用目录:"
          find . -type d -name "bin"
          exit 1
        fi
        
        echo "FIRMWARE_PATH=$FIRMWARE_PATH" >> $GITHUB_ENV
        
        # 检查关键固件文件（修正命名规则）
        REQUIRED_FILES=(
          "openwrt-$ARCH-$SUBARCH-generic-jd-be6500-squashfs-sysupgrade.bin"
          "openwrt-$ARCH-$SUBARCH-generic-rootfs.tar.gz"
          "openwrt-$ARCH-$SUBARCH-generic-ext4-fsck"
        )
        
        MISSING_FILES=()
        for file in "${REQUIRED_FILES[@]}"; do
          if [ ! -f "$FIRMWARE_PATH/$file" ]; then
            MISSING_FILES+=($file)
          fi
        done
        
        if [ ${#MISSING_FILES[@]} -gt 0 ]; then
          echo "❌ 发现缺失固件文件: ${MISSING_FILES[*]}"
          echo "可用文件:"
          ls -lh $FIRMWARE_PATH/* || true
          
          # 尝试查找其他可能的固件文件
          echo "其他可能的固件文件:"
          ls -lh $FIRMWARE_PATH/*jd-be6500* || true
          exit 1
        else
          echo "✅ 所有关键固件文件已生成"
          ls -lh $FIRMWARE_PATH/*.bin
        fi

    - name: 生成版本信息
      id: version
      run: |
        cd $OPENWRT_PATH
        RELEASE_DATE=$(date +%Y%m%d)
        COMMIT_ID=$(git rev-parse --short HEAD)
        BUILD_TIME=$(date +"%Y-%m-%d %H:%M:%S")
        BUILD_HOST=$(hostname)
        
        # 生成版本信息文件
        touch version.info
        echo "OpenWrt 固件 for JD BE6500 (IPQ5332)" > version.info
        echo "编译时间: $BUILD_TIME" >> version.info
        echo "编译主机: $BUILD_HOST" >> version.info
        echo "Git 提交: $COMMIT_ID" >> version.info
        echo "Lienol 分支: $LIENOL_BRANCH" >> version.info
        echo "目标平台: $ARCH/$SUBARCH" >> version.info
        
        # 输出版本变量
        echo "release_version=OpenWrt_${RELEASE_DATE}_${COMMIT_ID}" >> $GITHUB_ENV
        echo "release_version=OpenWrt_${RELEASE_DATE}_${COMMIT_ID}" >> $GITHUB_OUTPUT
        cat version.info

    - name: 上传固件到Artifact
      if: env.UPLOAD_FIRMWARE == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.release_version }}
        path: |
          ${{ env.FIRMWARE_PATH }}/*.bin
          ${{ env.FIRMWARE_PATH }}/*.tar.gz
          ${{ env.FIRMWARE_PATH }}/sha256sums
          version.info
        retention-days: 30
        if-no-files-found: error

    - name: 发布到GitHub Release
      if: env.UPLOAD_RELEASE == 'true' && github.event_name == 'release'
      uses: softprops/action-gh-release@v1
      with:
        name: ${{ env.release_version }}
        tag_name: ${{ env.release_version }}
        body_path: version.info
        files: |
          ${{ env.FIRMWARE_PATH }}/*.bin
          ${{ env.FIRMWARE_PATH }}/*.tar.gz
          ${{ env.FIRMWARE_PATH }}/sha256sums
          version.info
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.MY_TOKEN }}    
