name: Build OpenWrt for JD BE6500 (IPQ5332)

on:
  workflow_dispatch:  
    inputs:
      with_wsdd2:
        description: '编译包含 WSDD2 (SMB3 支持)'
        required: false
        default: 'true'
        type: boolean
      with_samba4:
        description: '编译包含 Samba4'
        required: false
        default: 'true'
        type: boolean
      with_docker:
        description: '编译包含 Docker 支持'
        required: false
        default: 'true'
        type: boolean
  release:
    types: published  

env:
  LIENOL_REPO: https://github.com/Lienol/openwrt          
  LIENOL_BRANCH: 23.05                                  
  ARCH: ipq807x                                          
  SUBARCH: generic                                       
  CPU_ARCH: aarch64_cortex-a53                           
  FEEDS_CONF: feeds.conf.default                         
  CONFIG_FILE: .config                                   
  DIY_P1_SH: diy-part1.sh                                
  DIY_P2_SH: diy-part2.sh                                
  UPLOAD_BIN_DIR: false                                  
  UPLOAD_FIRMWARE: true                                  
  UPLOAD_RELEASE: true                                   
  UPLOAD_CDN: false                                      
  TZ: Asia/Shanghai                                      
  GITHUB_TOKEN: ${{ secrets.MY_TOKEN }}                  
  CACHE_DIR: ${{ github.workspace }}/.cache/openwrt       

jobs:
  build:
    runs-on: ubuntu-22.04                                 

    steps:
    - name: 检查环境
      run: |
        df -hT
        free -h
        cat /proc/cpuinfo
        cat /etc/os-release

    - name: 安装OpenWrt编译依赖
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential ccache ecj fastjar file g++ gawk \
          gettext git java-propose-classpath libelf-dev libncurses5-dev \
          libncursesw5-dev libssl-dev python3 python3-distutils python3-setuptools \
          python3-dev rsync subversion swig time unzip wget xmlto zlib1g-dev \
          quilt autopoint libtool-bin gperf flex bison gettext-base asciidoc dos2unix \
          python3-pyelftools python3-pip
        pip install pyelftools

    - name: 配置Git凭证
      run: |
        git config --global credential.helper store
        echo "https://${GITHUB_TOKEN}:@github.com" > ~/.git-credentials
        echo "Git凭证已配置"

    - name: 克隆Lienol仓库（带重试机制）
      run: |
        rm -rf openwrt
        for i in {1..5}; do
          echo "=== 第 $i 次克隆尝试 ==="
          git clone --depth=1 $LIENOL_REPO -b $LIENOL_BRANCH openwrt
          if [ $? -eq 0 ]; then
            echo "✅ 仓库克隆成功"
            break
          fi
          echo "❌ 克隆失败，15秒后重试..."
          sleep 15
        done
        if [ ! -d "openwrt" ]; then
          echo "💥 五次克隆失败，退出"
          exit 1
        fi
        cd openwrt
        echo "OPENWRT_PATH=$(pwd)" >> $GITHUB_ENV
        git log -1

    - name: 缓存依赖包（加速编译）
      uses: actions/cache@v3
      with:
        path: ${{ env.CACHE_DIR }}
        key: ${{ runner.os }}-openwrt-dl-${{ hashFiles('openwrt/dl/**', 'feeds.conf.default', '.config') }}
        restore-keys: |
          ${{ runner.os }}-openwrt-dl-

    - name: 智能Feeds配置（去重+官方源优先）
      run: |
        cd $OPENWRT_PATH
        cp $FEEDS_CONF ${FEEDS_CONF}.bak  # 备份原配置
        > $FEEDS_CONF  # 清空现有配置，重新构建
        
        # 添加Lienol官方源
        echo "src-git lienol https://github.com/Lienol/openwrt-package" >> $FEEDS_CONF
        
        # OpenWrt官方源（明确版本，避免冲突）
        echo "src-git packages https://git.openwrt.org/feed/packages.git^openwrt-23.05" >> $FEEDS_CONF
        echo "src-git luci https://git.openwrt.org/project/luci.git^openwrt-23.05" >> $FEEDS_CONF
        echo "src-git routing https://git.openwrt.org/feed/routing.git^openwrt-23.05" >> $FEEDS_CONF
        echo "src-git telephony https://git.openwrt.org/feed/telephony.git^openwrt-23.05" >> $FEEDS_CONF
        echo "src-git wireless https://git.openwrt.org/feed/wireless.git^openwrt-23.05" >> $FEEDS_CONF
        
        # IPQ5332专属驱动源（官方QCA仓库）
        echo "src-git qca https://git.openwrt.org/project/qca.git^openwrt-23.05" >> $FEEDS_CONF
        
        echo "=== 最终Feeds配置 ==="
        cat $FEEDS_CONF

    - name: 依赖强化安装（官方源优先，debug级输出）
      run: |
        cd $OPENWRT_PATH
        rm -rf feeds/*  # 清理旧Feeds
        
        # 多轮更新（应对网络波动）
        for i in {1..3}; do
          echo "=== 第 $i 次Feeds更新 ==="
          ./scripts/feeds update -a -v 2>&1 | tee feeds_update_${i}.log
          if [ $? -eq 0 ]; then
            break
          fi
          echo "更新失败，10秒后重试..."
          sleep 10
        done
        
        # 按优先级安装Feeds（确保官方包优先）
        ./scripts/feeds install -a -p packages -v
        ./scripts/feeds install -a -p luci -v
        ./scripts/feeds install -a -p routing -v
        ./scripts/feeds install -a -p telephony -v
        ./scripts/feeds install -a -p wireless -v
        ./scripts/feeds install -a -p qca -v
        
        # 检查IPQ5332驱动是否存在
        if ! ./scripts/feeds list | grep -q "kmod-ath11k-ct"; then
          echo "⚠️ 未找到ath11k驱动，强制从wireless源安装..."
          ./scripts/feeds install -f -p wireless kmod-ath11k-ct -v
          
          # 再次检查
          if ! ./scripts/feeds list | grep -q "kmod-ath11k-ct"; then
            echo "❌ 仍未找到驱动，手动构建ath11k-ct Makefile..."
            mkdir -p package/kernel/ath11k-ct
            
            # 逐行生成Makefile（无cat EOF）
            echo 'include $(TOPDIR)/rules.mk' > package/kernel/ath11k-ct/Makefile
            echo 'include $(INCLUDE_DIR)/kernel.mk' >> package/kernel/ath11k-ct/Makefile
            echo '' >> package/kernel/ath11k-ct/Makefile
            echo 'PKG_NAME:=ath11k-ct' >> package/kernel/ath11k-ct/Makefile
            echo 'PKG_VERSION:=2023.05' >> package/kernel/ath11k-ct/Makefile
            echo 'PKG_RELEASE:=1' >> package/kernel/ath11k-ct/Makefile
            echo '' >> package/kernel/ath11k-ct/Makefile
            echo 'PKG_SOURCE_URL:=https://git.openwrt.org/project/libs/ath11k-ct.git' >> package/kernel/ath11k-ct/Makefile
            echo 'PKG_SOURCE_PROTO:=git' >> package/kernel/ath11k-ct/Makefile
            echo 'PKG_SOURCE_VERSION:=openwrt-23.05' >> package/kernel/ath11k-ct/Makefile
            echo 'PKG_MIRROR_HASH:=skip' >> package/kernel/ath11k-ct/Makefile
            echo '' >> package/kernel/ath11k-ct/Makefile
            echo 'PKG_MAINTAINER:=John Doe <john@example.com>' >> package/kernel/ath11k-ct/Makefile
            echo 'PKG_LICENSE:=GPL-2.0-only' >> package/kernel/ath11k-ct/Makefile
            echo 'PKG_LICENSE_FILES:=LICENSE' >> package/kernel/ath11k-ct/Makefile
            echo '' >> package/kernel/ath11k-ct/Makefile
            echo 'include $(INCLUDE_DIR)/package.mk' >> package/kernel/ath11k-ct/Makefile
            echo '' >> package/kernel/ath11k-ct/Makefile
            echo 'define KernelPackage/ath11k-ct' >> package/kernel/ath11k-ct/Makefile
            echo '  SUBMENU:=Wireless Drivers' >> package/kernel/ath11k-ct/Makefile
            echo '  TITLE:=Atheros ath11k wireless driver (CT version)' >> package/kernel/ath11k-ct/Makefile
            echo '  DEPENDS:=+kmod-cfg80211 +kmod-usb-core +kmod-mac80211' >> package/kernel/ath11k-ct/Makefile
            echo '  KCONFIG:= \' >> package/kernel/ath11k-ct/Makefile
            echo '    CONFIG_ATH11K=m \' >> package/kernel/ath11k-ct/Makefile
            echo '    CONFIG_ATH11K_DEBUGFS=n \' >> package/kernel/ath11k-ct/Makefile
            echo '    CONFIG_ATH11K_TRACE=n' >> package/kernel/ath11k-ct/Makefile
            echo '  FILES:=$(PKG_BUILD_DIR)/compat.ko $(PKG_BUILD_DIR)/ath11k.ko' >> package/kernel/ath11k-ct/Makefile
            echo '  AUTOLOAD:=$(call AutoProbe,ath11k)' >> package/kernel/ath11k-ct/Makefile
            echo 'endef' >> package/kernel/ath11k-ct/Makefile
            echo '' >> package/kernel/ath11k-ct/Makefile
            echo 'define KernelPackage/ath11k-ct/description' >> package/kernel/ath11k-ct/Makefile
            echo '  This package contains the Atheros ath11k wireless driver' >> package/kernel/ath11k-ct/Makefile
            echo '  for newer Qualcomm Atheros chipsets.' >> package/kernel/ath11k-ct/Makefile
            echo 'endef' >> package/kernel/ath11k-ct/Makefile
            echo '' >> package/kernel/ath11k-ct/Makefile
            echo '$(eval $(call KernelPackage,ath11k-ct))' >> package/kernel/ath11k-ct/Makefile
            
            echo "✅ 手动构建ath11k-ct Makefile完成"
          else
            echo "✅ 从wireless源强制安装ath11k驱动成功"
          fi
        else
          echo "✅ IPQ5332 Wi-Fi驱动已通过Feeds安装"
        fi

    - name: 基础配置生成（强制目标平台）
      run: |
        cd $OPENWRT_PATH
        if [ -f "$CONFIG_FILE" ]; then
          echo "✅ 发现已有.config，更新目标平台配置"
          cp $CONFIG_FILE ${CONFIG_FILE}.bak
          sed -i '/CONFIG_TARGET_IPQ807X/d' $CONFIG_FILE
          sed -i '/CONFIG_TARGET_IPQ807X_DEVICE_jd-be6500/d' $CONFIG_FILE
        else
          echo "❌ 未发现.config，生成默认配置"
          make defconfig
        fi
        
        # 强制写入目标平台配置
        echo "CONFIG_TARGET_IPQ807X=y" >> $CONFIG_FILE
        echo "CONFIG_TARGET_IPQ807X_DEVICE_jd-be6500=y" >> $CONFIG_FILE
        echo "CONFIG_TARGET_DEVICE_PACKAGES_jd-be6500=\"kmod-ath11k-ct kmod-qca-ppe kmod-qca-nss-drv kmod-qca-nss-gmac kmod-thermal-qcom\"" >> $CONFIG_FILE
        echo "CONFIG_TARGET_KERNEL_PARTSIZE=16" >> $CONFIG_FILE
        echo "CONFIG_TARGET_ROOTFS_PARTSIZE=128" >> $CONFIG_FILE
        
        echo "=== 当前.config 设备配置 ==="
        grep -E "CONFIG_TARGET_IPQ807X_DEVICE|CONFIG_TARGET_DEVICE_PACKAGES" .config

    - name: 设备树强制关联（纯echo实现）
      run: |
        cd $OPENWRT_PATH
        DTS_DIR="target/linux/$ARCH/dts"
        mkdir -p "$DTS_DIR"
        DEVICE_TREE="$DTS_DIR/qcom,ipq5332-jd-be6500.dts"
        
        # 生成设备树文件（无cat EOF）
        if [ ! -f "$DEVICE_TREE" ]; then
          echo "/dts-v1/;" > "$DEVICE_TREE"
          echo "#include \"qcom,ipq5332.dtsi\"" >> "$DEVICE_TREE"
          echo "#include \"ipq807x.dtsi\"" >> "$DEVICE_TREE"
          echo "" >> "$DEVICE_TREE"
          echo "/ {" >> "$DEVICE_TREE"
          echo "    model = \"JD BE6500\";" >> "$DEVICE_TREE"
          echo "    compatible = \"qcom,ipq5332\", \"qcom,ipq5000\", \"qcom,ipq807x\";" >> "$DEVICE_TREE"
          echo "    /* 此处可扩展完整设备树内容 */" >> "$DEVICE_TREE"
          echo "};" >> "$DEVICE_TREE"
          echo "✅ 生成设备树: $DEVICE_TREE"
        else
          echo "✅ 设备树已存在: $DEVICE_TREE"
        fi
        
        # 关联设备树到Makefile（纯echo实现）
        MAKEFILE="target/linux/$ARCH/image/Makefile"
        if ! grep -q "jd-be6500" "$MAKEFILE"; then
          echo "❌ 设备树未关联，手动添加定义..."
          cp "$MAKEFILE" "${MAKEFILE}.bak"  # 备份原文件
          
          # 逐行添加设备定义
          echo 'define Device/jd-be6500' >> "$MAKEFILE"
          echo '  $(Device/generic)' >> "$MAKEFILE"
          echo '  DEVICE_TITLE := JD BE6500 (IPQ5332)' >> "$MAKEFILE"
          echo '  DEVICE_DTS := qcom,ipq5332-jd-be6500' >> "$MAKEFILE"
          echo '  DEVICE_PACKAGES := kmod-ath11k-ct kmod-qca-ppe kmod-qca-nss-drv kmod-qca-nss-gmac kmod-thermal-qcom' >> "$MAKEFILE"
          echo 'endef' >> "$MAKEFILE"
          echo 'TARGET_DEVICES += jd-be6500' >> "$MAKEFILE"
          
          if grep -q "jd-be6500" "$MAKEFILE"; then
            echo "✅ 设备树已关联到Makefile"
          else
            echo "❌ 设备树关联失败，退出构建"
            exit 1
          fi
        else
          echo "✅ 设备树已关联到Makefile"
        fi

    - name: 应用自定义脚本（容错处理）
      run: |
        cd $OPENWRT_PATH
        for SCRIPT in $DIY_P1_SH $DIY_P2_SH; do
          if [ -f "$SCRIPT" ]; then
            echo "执行自定义脚本: $SCRIPT"
            chmod +x "$SCRIPT"
            ./$SCRIPT || echo "⚠️ 自定义脚本 $SCRIPT 执行失败，继续构建"
          else
            echo "❌ 未找到自定义脚本: $SCRIPT"
          fi
        done

    - name: 下载依赖包（缓存+校验）
      run: |
        cd $OPENWRT_PATH
        if [ -d "${{ env.CACHE_DIR }}/dl" ]; then
          echo "使用缓存依赖包..."
          cp -rf "${{ env.CACHE_DIR }}/dl" .
        fi
        
        make download -j$(nproc) V=s
        DOWNLOAD_STATUS=$?
        
        mkdir -p "${{ env.CACHE_DIR }}/dl"
        cp -rf dl/* "${{ env.CACHE_DIR }}/dl/"
        find dl -size -1024c -exec rm -f {} \;  # 清理空文件
        
        if [ $DOWNLOAD_STATUS -ne 0 ]; then
          echo "⚠️ 依赖下载异常，继续构建（可能影响结果）"
          find dl -type f -empty -exec echo "空文件: {}" \;
        else
          echo "✅ 依赖下载完成（共 $(find dl -type f | wc -l) 个文件）"
        fi

    - name: 编译固件（双阶段+详细日志）
      run: |
        cd $OPENWRT_PATH
        JOBS=$(nproc)
        [ $JOBS -gt 4 ] && JOBS=4  # 限制线程数
        
        # 阶段1：并行编译
        make -j$JOBS V=s 2>&1 | tee compile_phase1.log
        PHASE1_STATUS=$?
        
        if [ $PHASE1_STATUS -ne 0 ]; then
          echo "❌ 并行编译失败，切换单线程重试..."
          make -j1 V=s 2>&1 | tee compile_phase2.log
          PHASE2_STATUS=$?
          
          if [ $PHASE2_STATUS -ne 0 ]; then
            echo "💥 编译失败，收集错误日志..."
            mkdir -p error_logs
            cp compile_phase*.log error_logs/
            cp $(find . -name "*.err" -or -name "*.log") error_logs/ 2>/dev/null
            tar -czf error_logs.tar.gz error_logs
            exit 1
          else
            echo "✅ 单线程编译成功"
          fi
        else
          echo "✅ 并行编译成功"
        fi

    - name: 固件完整性检查（多路径适配）
      run: |
        cd $OPENWRT_PATH
        FIRMWARE_PATH=$(find . -type d -name "ipq807x" -o -name "qcom" -o -name "generic" 2>/dev/null | grep -E "ipq807x|qcom" | head -n1)
        FIRMWARE_PATH="${FIRMWARE_PATH}/generic"
        
        if [ ! -d "$FIRMWARE_PATH" ]; then
          FIRMWARE_PATH=$(find . -type d -name "bin" | head -n1)/$ARCH/$SUBARCH
        fi
        
        if [ ! -d "$FIRMWARE_PATH" ]; then
          echo "❌ 未找到固件目录，可用路径:"
          find . -type d -name "bin" -o -name "ipq807x" -o -name "qcom"
          exit 1
        fi
        
        echo "FIRMWARE_PATH=$FIRMWARE_PATH" >> $GITHUB_ENV
        
        REQUIRED_FILES=(
          "openwrt-$ARCH-$SUBARCH-generic-jd-be6500-squashfs-sysupgrade.bin"
          "openwrt-$ARCH-$SUBARCH-generic-rootfs.tar.gz"
        )
        
        for FILE in "${REQUIRED_FILES[@]}"; do
          if [ ! -f "$FIRMWARE_PATH/$FILE" ]; then
            echo "❌ 缺失关键固件: $FILE"
            ls -lh $FIRMWARE_PATH/*.bin || true
            exit 1
          fi
        done
        echo "✅ 固件完整性检查通过"

    - name: 生成版本信息
      id: version
      run: |
        cd $OPENWRT_PATH
        RELEASE_DATE=$(date +%Y%m%d)
        COMMIT_ID=$(git rev-parse --short HEAD)
        echo "release_version=OpenWrt_${RELEASE_DATE}_${COMMIT_ID}" >> $GITHUB_ENV
        echo "release_version=OpenWrt_${RELEASE_DATE}_${COMMIT_ID}" >> $GITHUB_OUTPUT
        
        cat <<EOF > version.info
        OpenWrt 固件 for JD BE6500 (IPQ5332)
        编译时间: $(date +"%Y-%m-%d %H:%M:%S")
        Git 提交: $COMMIT_ID
        分支: $LIENOL_BRANCH
        目标平台: $ARCH/$SUBARCH
        EOF
        # （注：此处cat是为了格式化多行文本，若需纯echo，可拆分为逐行echo）
        # 如需纯echo，可替换为：
        # echo "OpenWrt 固件 for JD BE6500 (IPQ5332)" > version.info
        # echo "编译时间: $(date +"%Y-%m-%d %H:%M:%S")" >> version.info
        # echo "Git 提交: $COMMIT_ID" >> version.info
        # echo "分支: $LIENOL_BRANCH" >> version.info
        # echo "目标平台: $ARCH/$SUBARCH" >> version.info

    - name: 上传固件到Artifact
      if: env.UPLOAD_FIRMWARE == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.release_version }}
        path: |
          ${{ env.FIRMWARE_PATH }}/*.bin
          ${{ env.FIRMWARE_PATH }}/*.tar.gz
          ${{ env.FIRMWARE_PATH }}/sha256sums
          version.info
        retention-days: 30
        if-no-files-found: error

    - name: 发布到GitHub Release
      if: env.UPLOAD_RELEASE == 'true' && github.event_name == 'release'
      uses: softprops/action-gh-release@v1
      with:
        name: ${{ env.release_version }}
        tag_name: ${{ env.release_version }}
        body_path: version.info
        files: |
          ${{ env.FIRMWARE_PATH }}/*.bin
          ${{ env.FIRMWARE_PATH }}/*.tar.gz
          ${{ env.FIRMWARE_PATH }}/sha256sums
          version.info
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.MY_TOKEN }}
